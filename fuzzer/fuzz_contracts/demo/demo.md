# Demo fuzzing target

This tutorial demonstrates the basic fuzzing setup for a demo Solidity smart contract.

As part of this tutorial, we will:

1. Define a Solidity contract to fuzz.
2. Define a fuzzing target.
3. Run the fuzzing.
4. Analyze the results.

## 1. Contract to fuzz

As a demo example, we will use the following simple Solidity contract:

```solidity
contract test {
    function should_always_return_0(uint8 input) public pure returns (uint8) {
        if (input == 10) {
            return 1;
        }
        return 0;
    }
}
```

As you can see, the contract has a single function `should_always_return_0` that returns `1` if the input is `10` and `0` otherwise. Our goal is to fuzz this function and find the "edge case" when the function returns `1`.

## 2. Defining fuzzing target

Our Rust fuzzing target will call the `should_always_return_0` function with with the inputs generated by the fuzzer and check if the output is `0`. Our goal is to find the input that will make the function return `1`.

When we define fuzzing target in the `fuzz_targets/demo.rs` file, we should provide the following:

1. The input contract file path.
2. The function to fuzz.
3. The input parameter types.
4. The expected output.

Here is the example of the `FuzzingCase` structure definition for the `fuzz_targets/demo.rs` target:

```rust
let case = common::FuzzingCase {
    contract_path: String::from("fuzz/fuzz_contracts/demo/demo.sol"),
    function_name: String::from("should_always_return_0"),
    input_types: vec![common::TypeVariant::integer_unsigned(8)], // <-- input types must match the contract function signature
    inputs: vec![common::integer_literal(data)], // <-- use the fuzzer input here
    expected_output: common::integer_literal(0), // <-- expect the output to be 0
};
```

It's important that the input types and the expected output are defined correctly to match the contract function signature. Otherwise, the contract function will throw an exception and the fuzzing fails.

After defining the fuzzing case, we can generate the test and execute it:

```rust
// Generate fuzzing test
let test = common::gen_fuzzing_test(case).expect("Error: cannot build fuzzing test!");
// Run test and check the results
let result = common::build_and_run(test).expect("Error: cannot execute fuzzing test!");
// Check if the test was successful
assert!(result.is_successful())
```

## 3. Running the fuzzing

To run the fuzzing, execute the following command:

```bash
cargo fuzz run demo
```

The fuzzer will start generating the inputs and running the tests. If the fuzzer finds the input that makes the function return `1`, it will report the test as failed and stops fuzzing.

## 4. Analyzing the results

Sooner or later, the fuzzer will find the input that makes the function return `1`. The fuzzer will report the test as failed and stop fuzzing.

Here is an example of the output:

```bash
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1801896173
INFO: Loaded 1 modules   (1847630 inline 8-bit counters): 1847630 [0x10db478d0, 0x10dd0aa1e), 
INFO: Loaded 1 PC tables (1847630 PCs): 1847630 [0x10dd0aa20,0x10f93bf00), 
INFO:       24 files found in /Users/abalias/projects/compiler-tester/fuzz/corpus/demo
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: seed corpus: files: 24 min: 1b max: 4b total: 45b rss: 92Mb
Generating fuzzing test with input 47...
Y+M3B3 0.8.24     PASSED fuzz/fuzz_contracts/demo/demo.sol[#deployer:fuzz/fuzz_contracts/demo/demo.sol:test] (size 864, cycles 1550, gas 1125949)
Y+M3B3 0.8.24     PASSED fuzz/fuzz_contracts/demo/demo.sol[should_always_return_0:1] (cycles 29, gas 348)
Generating fuzzing test with input 39...
Y+M3B3 0.8.24     PASSED fuzz/fuzz_contracts/demo/demo.sol[#deployer:fuzz/fuzz_contracts/demo/demo.sol:test] (size 864, cycles 1550, gas 1125949)
Y+M3B3 0.8.24     PASSED fuzz/fuzz_contracts/demo/demo.sol[should_always_return_0:1] (cycles 29, gas 348)
... <skipped many variations> ...
Generating fuzzing test with input 10...
 Downloading compiler binaries
    Finished downloading compiler binaries in 0m00s
      Loaded the System Contracts from `system-contracts-stable-build`
       Saved the System Contracts to `system-contracts-stable-build`
Y+M3B3 0.8.24     PASSED fuzz/fuzz_contracts/demo/demo.sol[#deployer:fuzz/fuzz_contracts/demo/demo.sol:test] (size 864, cycles 1550, gas 1125949)
Y+M3B3 0.8.24     FAILED fuzz/fuzz_contracts/demo/demo.sol[should_always_return_0:1] (expected (
    return_data: [
        "0x0000000000000000000000000000000000000000000000000000000000000000",
    ],
    exception: false,
    events: [],
), found (
    return_data: [
        "0x0000000000000000000000000000000000000000000000000000000000000001",
    ],
    exception: false,
    events: [],
), calldata 0a1a369d000000000000000000000000000000000000000000000000000000000000000a)
thread '' panicked at fuzz/fuzz_targets/demo.rs:26:5:
assertion failed: result.is_successful()
```

As you can see, the fuzzer found the input `10` that makes the function return `1`. The test failed as expected.
