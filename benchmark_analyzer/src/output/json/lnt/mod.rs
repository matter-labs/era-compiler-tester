//!
//! JSON format compatible with LNT.
//!

pub mod benchmark;

use std::collections::BTreeMap;
use std::path::PathBuf;

use benchmark::machine::Machine;
use benchmark::run_description::RunDescription;
use benchmark::test_description::TestDescription;
use benchmark::LntBenchmark;

use crate::model::benchmark::test::metadata::Metadata as TestMetadata;
use crate::model::benchmark::test::selector::Selector;
use crate::model::benchmark::test::Test;
use crate::model::benchmark::Benchmark;
use crate::output::json::lnt::benchmark::LntReportFormatVersion;

///
/// Serialize the benchmark to a set of JSON files compatible with LNT format.
///
#[derive(Default)]
pub struct JsonLNT {
    /// List of files generated by the benchmark analyzer.
    pub files: BTreeMap<String, LntBenchmark>,
}

impl JsonLNT {
    ///
    /// Generate the test name for a measurement, containing a unique test identifier.
    ///
    fn test_name(selector: &Selector) -> String {
        let Selector {
            project: path,
            case,
            input,
            ..
        } = selector;
        let short_path = Self::shorten_file_name(path);
        let short_input = match input {
            Some(crate::Input::Deployer {
                contract_identifier,
            }) => Some(crate::Input::Deployer {
                contract_identifier: Self::shorten_file_name(contract_identifier),
            }),
            _ => input.clone(),
        };
        Selector {
            project: short_path.to_string(),
            case: case.clone(),
            input: short_input,
        }
        .to_string()
    }

    ///
    /// Shorten the file name to only include the last directory and the file name.
    ///
    fn shorten_file_name(name: &str) -> String {
        let path_buf = PathBuf::from(name);
        if let Some(parent) = path_buf.parent() {
            if let Some(file_name) = path_buf.file_name() {
                if let Some(dir_name) = parent.file_name() {
                    return format!(
                        "{}/{}",
                        dir_name.to_string_lossy(),
                        file_name.to_string_lossy()
                    );
                }
            }
        }
        path_buf.to_str().expect("Always valid").to_string()
    }
}

impl TryFrom<Benchmark> for JsonLNT {
    type Error = anyhow::Error;

    fn try_from(benchmark: Benchmark) -> anyhow::Result<Self, Self::Error> {
        let mut files: BTreeMap<String, LntBenchmark> = Default::default();

        let context = if let Some(context) = &benchmark.metadata.context {
            context
        } else {
            anyhow::bail!("LNT backend requires explicitly passed benchmark context, but no context was provided.");
        };

        for (
            _name,
            Test {
                metadata: TestMetadata { selector, .. },
                toolchain_groups,
            },
        ) in benchmark.tests.into_iter()
        {
            for (_toolchain, toolchain_group) in toolchain_groups.into_iter() {
                for (codegen, codegen_group) in toolchain_group.codegen_groups.into_iter() {
                    for (version, versioned_group) in codegen_group.versioned_groups.into_iter() {
                        for (
                            optimization,
                            crate::Executable {
                                run: measurements, ..
                            },
                        ) in versioned_group.executables.into_iter()
                        {
                            let machine_name =
                                format!("{}-{version}-{codegen}{optimization}", context.machine);

                            let machine = Machine {
                                name: context.machine.clone(),
                                target: context.target,
                                codegen: codegen.clone(),
                                optimization: optimization.clone(),
                                toolchain: context.toolchain.clone(),
                            };
                            let run = RunDescription {
                                llvm_project_revision: benchmark.metadata.start,
                                start_time: benchmark.metadata.start,
                                end_time: benchmark.metadata.end,
                                llvm_version: context.llvm_version.clone(),
                                version: context.compiler_version.clone(),
                            };
                            files
                                .entry(machine_name)
                                .or_insert(LntBenchmark {
                                    format_version: LntReportFormatVersion::V2,
                                    machine,
                                    run,
                                    tests: vec![],
                                })
                                .tests
                                .push(TestDescription {
                                    name: { Self::test_name(&selector) },
                                    measurements: measurements.clone(),
                                });
                        }
                    }
                }
            }
        }

        Ok(Self { files })
    }
}
